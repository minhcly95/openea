<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenEA: Write custom operators using the API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenEA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut4.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Write custom operators using the API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tut4-problem">Sphere Optimization problem</a></li>
<li class="level1"><a href="#tut4-desc">Algorithm Description</a></li>
<li class="level1"><a href="#tut4-opertors">Implementation</a><ul><li class="level2"><a href="#tut4-norm">Normalization</a></li>
<li class="level2"><a href="#tut4-init">Initialization</a></li>
<li class="level2"><a href="#tut4-mutation">Mutation</a></li>
<li class="level2"><a href="#tut4-recombination">Recombination</a></li>
<li class="level2"><a href="#tut4-main">Main program</a></li>
</ul>
</li>
<li class="level1"><a href="#tut4-compile">Compile and Run</a></li>
<li class="level1"><a href="#tut4-conclution">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This page describes the process of implementing custom operators.</p>
<dl class="section user"><dt>Tutorial level</dt><dd>Intermediate</dd></dl>
<dl class="section user"><dt>Previous tutorial</dt><dd><a class="el" href="tut3.html">Control the algorithm via CLI options</a></dd></dl>
<dl class="section user"><dt>Next tutorial</dt><dd><a class="el" href="tut5.html">Bundle custom operators into a Plugin</a></dd></dl>
<h1><a class="anchor" id="tut4-problem"></a>
Sphere Optimization problem</h1>
<p>This problem is took from page 249 of the book <b>How to Solve It: Modern Heuristics</b>, 2004, by <em>Z. Michalewicz</em> and <em>D.B. Fogel</em>. The problem has no name, so I named it the Sphere Optimization problem (SO). The problem can be described as follow:</p>
<dl class="section user"><dt>Sphere Optimization problem</dt><dd>Find a vector of real numbers \({\bf x}=\{x_1,x_2,...,x_n\}\) which maximizes:</dd></dl>
<p class="formulaDsp">
\[ SO({\bf x}) = (\sqrt{n})^n \prod_{i=1}^n x_i \]
</p>
<dl class="section user"><dt></dt><dd>where \(\sum_{i=1}^n x_i^2 = 1\) and \(0 \leq x_i \leq 1\) for \(1 \leq i \leq n\).</dd></dl>
<p>The global solution is at \((x_1,...,x_n) = (\frac{1}{\sqrt{n}},...,\frac{1}{\sqrt{n}})\) and the optimal value is \(SO({\bf x}) = 1\). What makes the problem interesting is the hard constraint forces us to search on a hyper-sphere manifold, so we must design specialized mutation, recombination and also initialization operators in order to find a feasible solution (not violating the constraint). Therefore this is a very good example for us to write some custom operators.</p>
<h1><a class="anchor" id="tut4-desc"></a>
Algorithm Description</h1>
<p>Before jumping in the implemetation, we should again discuss and write out our algorithm description. The difficulty of this problem is that in order to maintain its feasibility, we can't adjust any component of \(\bf x\) without changing others. Therefore, we must write custom operators to initialize a feasible population in the first place and maintain that feasibility via specialized mutation and recombination methods.</p>
<p>To initialize a feasible solution, first, we just need to randomize a vector \({\bf y}=\{y_1,y_2,...,y_n\}\) normally, then calculate its L2-norm \(||{\bf y}||=\sqrt{\sum_{i=1}^n y_i^2}\) and assign \({\bf x} = \frac{\bf y}{||{\bf y}||}\).</p>
<dl class="section note"><dt>Note</dt><dd>This random initialization method is not uniform. However, the work spent on designing a totally fair initialization method might even greater than the work needed to solve the problem. Anyway, we are using a heuristic method to solve the problem, so don't be so obsessed with a perfect solution for everything.</dd></dl>
<p>Mutation can be done by multiplying a random component \(x_i\) with \(p\) in \([0, 1]\) and another \(x_j\) with \(q = \sqrt{(x_i/x_j)^2(1-p^2) + 1}\), so we will have:</p>
<p class="formulaDsp">
\begin{eqnarray*} x&#39;^2_i + x&#39;^2_j &amp;=&amp; (p\cdot x_i)^2 + (q\cdot x_j)^2\\ &amp;=&amp; p^2x_i^2 + ((x_i/x_j)^2(1-p^2) + 1)x_j^2\\ &amp;=&amp; p^2x_i^2 + x_i^2(1-p^2) + x_j^2\\ &amp;=&amp; x^2_i + x^2_j \end{eqnarray*}
</p>
<p>So the constraint won't be violated because the sum of squares before and after mutation is the same.</p>
<p>The specialized recombination operator will be used in this tutorial is called <em>sphere crossover</em>. It takes two vectors \({\bf x}\) and \({\bf y}\) as parents and spawns an offspring \({\bf z}\) whose component value is calculated by \(z_i = \sqrt{\alpha x^2_i + (1 - \alpha)y^2_i}\) with \(i \in [1, n]\) and \(\alpha\) randomly chosen in \([0, 1]\). If we examine the feasibility of \({\bf z}\):</p>
<p class="formulaDsp">
\begin{eqnarray*} \sum_{i=1}^n z_i^2 &amp;=&amp; \sum_{i=1}^n \left( \alpha x^2_i + (1 - \alpha)y^2_i \right)\\ &amp;=&amp; \alpha \sum_{i=1}^n x^2_i + (1 - \alpha) \sum_{i=1}^n y^2_i\\ &amp;=&amp; \alpha + (1 - \alpha) = 1 \end{eqnarray*}
</p>
<p>and hence \({\bf z}\) doesn't violate the constraint.</p>
<dl class="section note"><dt>Note</dt><dd>The result of mutation and the recombination is only valid if the input vectors are feasible. But because we initialize the population with only feasible solutions, and our mutation and recombination operators generate feasible output from feasible inputs, so our population will be always feasible (it is similar to proof by induction). This constraint handling technique is called <b>preservation of feasibility by specialized operators</b>. There are many other techniques to handle constraints, but we are trying to write some custom operators so we will stick with this technique.</dd></dl>
<p>With our custom operators, we can then design our algorithm as in the following description:</p>
<table class="doxtable">
<tr>
<td>Representation </td><td>An array of double of length <em>n</em>  </td></tr>
<tr>
<td>Evaluation function </td><td>The function \(SO({\bf x})\)  </td></tr>
<tr>
<td>Recombination </td><td>Sphere crossover (described above)  </td></tr>
<tr>
<td>Offspring ratio </td><td>100%  </td></tr>
<tr>
<td>Mutation </td><td>Sphere mutation (described above)  </td></tr>
<tr>
<td>Mutation probability </td><td>10%  </td></tr>
<tr>
<td>Parent selection </td><td>Uniform (random)  </td></tr>
<tr>
<td>Survival selection </td><td>Tournament with size 5  </td></tr>
<tr>
<td>Population size </td><td>100  </td></tr>
<tr>
<td>Initialization </td><td>Sphere initialization (described above)  </td></tr>
<tr>
<td>Terminal condition </td><td>After 10000 generations  </td></tr>
</table>
<p>In the following implementation, we will assign the default length of the vector <em>n</em> = 25.</p>
<h1><a class="anchor" id="tut4-opertors"></a>
Implementation</h1>
<p>In this tutorial, we will implement this algorithm by using the C++ API. In the next tutorial, we will use CLI to launch our program instead. I recommend you to implement a working algorithm using C++ API first, then convert it to plugin for CLI later.</p>
<p>Here I won't show the full code. You can find the full source listing here:</p>
<p><a class="el" href="_sphere_opt_8cpp.html">SphereOpt.cpp</a></p>
<h2><a class="anchor" id="tut4-norm"></a>
Normalization</h2>
<p>Before we implement those operators described above, you must understand that in C++, double type has finite precision, therefore result of calculations might be round up or down. This effect won't hurt if you only do the calculation once. But in our algorithm, these errors will be added up generation by generation, and eventually, the constraint will be violated (at a recognizable scale). The solution for this is when a vector is modified, it must come with a normalization, similar to the process we used for the sphere initialization method, and the errors won't have chance to add up. Here, I created a function named <code>Normalize()</code> to keep our vectors valid:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Normalize(vector&lt;double&gt;&amp; x) {</div><div class="line">    <span class="keywordtype">double</span> norm = 0;</div><div class="line">    <span class="keywordflow">for</span> (<a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> i = 0; i &lt; x.size(); i++)</div><div class="line">        norm += x[i] * x[i];</div><div class="line">    norm = <a class="codeRef" doxygen="/home/minh/repo/vgu_interns/EA/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/numeric/math/sqrt.html">sqrt</a>(norm);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> i = 0; i &lt; x.size(); i++)</div><div class="line">        x[i] /= norm;</div><div class="line">}</div></div><!-- fragment --><p> We can start writing our operators now.</p>
<h2><a class="anchor" id="tut4-init"></a>
Initialization</h2>
<p>The normalization process above also implements a part of the initialization. What is left to do is to generate a random vector. Initialization method must derive from <a class="el" href="classea_1_1_initializer.html" title="The interface for initialization method. ">Initializer</a> interface. There is no type-casting helper for <a class="el" href="classea_1_1_initializer.html" title="The interface for initialization method. ">Initializer</a> now, so you need to convert between types by yourself. Here is the implementation:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SphereInitializer: <span class="keyword">public</span> Initializer {</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> mLength;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    SphereInitializer(<a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> pLength) : mLength(pLength) { }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="namespaceea.html#a38644d5f803b70178921a14584bde13b">GenomePoolPtr</a> DoInitialize(<a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> pSize)<span class="keyword"> override </span>{</div><div class="line">        <a class="code" href="namespaceea.html#a38644d5f803b70178921a14584bde13b">GenomePoolPtr</a> pool = make_shared&lt;GenomePool&gt;();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> i = 0; i &lt; pSize; i++) {</div><div class="line">            <a class="code" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a> newGenome = make_shared&lt;DoubleArrayGenome&gt;();</div><div class="line">            vector&lt;double&gt;&amp; x = newGenome-&gt;GetGenes();</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> j = 0; j &lt; mLength; j++)</div><div class="line">                x.push_back(<a class="code" href="classea_1_1_random.html#ac1494cf864d252f9bf25ac32cd65f2ff">Random::Rate</a>());</div><div class="line"></div><div class="line">            Normalize(x);</div><div class="line"></div><div class="line">            pool-&gt;push_back(static_pointer_cast&lt;Genome&gt;(newGenome));</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> pool;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> The interface gives you a integer for the expected size and what you need to do is to return a pointer of a vector of <a class="el" href="namespaceea.html#a4a32fea65fea1f8fc03d446545b73686">GenomePtr</a> with the given size. These <a class="el" href="namespaceea.html#a4a32fea65fea1f8fc03d446545b73686">GenomePtr</a> must be <b>independent</b>, that means they <b>can not</b> share a same reference of <a class="el" href="classea_1_1_genome.html" title="The interface for representation. ">Genome</a>.</p>
<p>In the API, we mostly work with smart pointers. Smart pointers must be created by the function <a class="elRef" doxygen="/home/minh/repo/vgu_interns/EA/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared.html">std::make_shared()</a> as opposed to the <code><b>new</b></code> keyword of normal pointer. However, you don't need to <code><b>delete</b></code> a smart pointer, it is automatically deleted if there is no reference to the object anymore (that's why it is called "smart"). You can not cast smart pointer in the old fashion also (std::static_cast() and std::dynamic_cast()), you must use smart pointer casting functions such as <a class="elRef" doxygen="/home/minh/repo/vgu_interns/EA/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast.html">std::static_pointer_cast()</a> and <a class="elRef" doxygen="/home/minh/repo/vgu_interns/EA/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast.html">std::dynamic_pointer_cast()</a>. For example, you can create the <a class="el" href="namespaceea.html#a368dd3b5172ef13b010815e13baf9d72">VectorPtr</a> to return as the result of the function by using:</p>
 <div class="fragment"><div class="line">        <a class="code" href="namespaceea.html#a38644d5f803b70178921a14584bde13b">GenomePoolPtr</a> pool = make_shared&lt;GenomePool&gt;();</div></div><!-- fragment --></p>
<p>Then create a <a class="el" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a> by: <div class="fragment"><div class="line">            <a class="code" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a> newGenome = make_shared&lt;DoubleArrayGenome&gt;();</div></div><!-- fragment --></p>
<p>The vector can only contain <a class="el" href="namespaceea.html#a4a32fea65fea1f8fc03d446545b73686">GenomePtr</a> so at the end, you must cast back by using: <div class="fragment"><div class="line">            pool-&gt;push_back(static_pointer_cast&lt;Genome&gt;(newGenome));</div></div><!-- fragment --></p>
<p>When working with <a class="el" href="namespaceea.html#a60079f1a7f760e9ddf64370e88c73ca5">DoubleArrayGenome</a>, we must access its content via a reference of <a class="elRef" doxygen="/home/minh/repo/vgu_interns/EA/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>:  <div class="fragment"><div class="line">            vector&lt;double&gt;&amp; x = newGenome-&gt;GetGenes();</div></div><!-- fragment --></p>
<p>Remember to always use reference to access the content of the <a class="el" href="classea_1_1_array_genome.html" title="Genome which stores an array of genes of type T. ">ArrayGenome</a>. If you use normal type, the information will be copied and you cannot actually set values to the real content. We need to fill the content with random numbers. The library provides the static function <a class="el" href="classea_1_1_random.html#ac1494cf864d252f9bf25ac32cd65f2ff" title="Generate a random rate between 0.0 and 1.0 inclusively. ">Random::Rate()</a> to generate a random double number from 0 to 1 (exclusive). <div class="fragment"><div class="line">            <span class="keywordflow">for</span> (<a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> j = 0; j &lt; mLength; j++)</div><div class="line">                x.push_back(<a class="code" href="classea_1_1_random.html#ac1494cf864d252f9bf25ac32cd65f2ff">Random::Rate</a>());</div></div><!-- fragment --></p>
<p>After having the vector filled, we will use the normalization function created in the previous step to make our vector valid: <div class="fragment"><div class="line">            Normalize(x);</div></div><!-- fragment --></p>
<h2><a class="anchor" id="tut4-mutation"></a>
Mutation</h2>
<p>We will then write our <a class="el" href="classea_1_1_mutator.html" title="The interface for mutation operator. ">Mutator</a> next. Mutation operator inherits from <a class="el" href="classea_1_1_mutator.html" title="The interface for mutation operator. ">Mutator</a>, but in this case, we knew that we want to use <a class="el" href="namespaceea.html#a60079f1a7f760e9ddf64370e88c73ca5">DoubleArrayGenome</a>, therefore our operator should derive from <a class="el" href="classea_1_1_typed_mutator.html" title="A Mutator which requires the input and output Genome of type T instead of Genome. ...">TypedMutator</a> instead so we don't need to handle type-casting. Here is the implementation:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SphereMutation: <span class="keyword">public</span> TypedMutator&lt;DoubleArrayGenome&gt; {</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a> DoApply(<span class="keyword">const</span> <a class="code" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a>&amp; pTarget)<span class="keyword"> override </span>{</div><div class="line">        <a class="code" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a> newGenome = pTarget-&gt;Clone();</div><div class="line">        pair&lt;uint, uint&gt; pair = Random::Pair&lt;uint&gt;(0, pTarget-&gt;GetSize() - 1);</div><div class="line"></div><div class="line">        vector&lt;double&gt;&amp; x = newGenome-&gt;GetGenes();</div><div class="line">        <a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> i = pair.first, j = pair.second;</div><div class="line">        <span class="keywordtype">double</span> p = <a class="code" href="classea_1_1_random.html#ac1494cf864d252f9bf25ac32cd65f2ff">Random::Rate</a>();</div><div class="line">        <span class="keywordtype">double</span> q = <a class="codeRef" doxygen="/home/minh/repo/vgu_interns/EA/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/numeric/math/sqrt.html">sqrt</a>(<a class="codeRef" doxygen="/home/minh/repo/vgu_interns/EA/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/numeric/math/pow.html">pow</a>(x[i] / x[j], 2) * (1 - p * p) + 1);</div><div class="line">        x[i] *= p;</div><div class="line">        x[j] *= q;</div><div class="line"></div><div class="line">        Normalize(x);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> newGenome;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> The interface requires a <a class="el" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a> as input and another <a class="el" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a> as output. These two pointers must point to <b>different objects</b>, therefore we need to <b>clone</b> our genome before applying any modification:</p>
<p><div class="fragment"><div class="line">        <a class="code" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a> newGenome = pTarget-&gt;Clone();</div></div><!-- fragment --></p>
<p>The next random function you should know is <a class="el" href="classea_1_1_random.html#afac8e3ef86438b238e3761e821d980d3" title="Generate a random pair of integers. ">Random::Pair()</a> which will generate a pair of integer numbers. These two numbers are guaranteed to be different.</p>
<p><div class="fragment"><div class="line">        pair&lt;uint, uint&gt; pair = Random::Pair&lt;uint&gt;(0, pTarget-&gt;GetSize() - 1);</div><div class="line">        <a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> i = pair.first, j = pair.second;</div></div><!-- fragment --></p>
<p>The calculation is straight-forward. Notice that at the end, we normalize the vector again:</p>
<p><div class="fragment"><div class="line">        Normalize(x);</div></div><!-- fragment --></p>
<dl class="section note"><dt>Note</dt><dd>You may think, if we normalize the output eventually to make it feasible, why would we need to design the operators to preverse the feasibility. The answer is, the normalization is only an implementation feature in practice. What we want is an effective search, not a completely blind search, and searching on the the manifold created by the constraint is much more effective than searching the whole space.</dd></dl>
<h2><a class="anchor" id="tut4-recombination"></a>
Recombination</h2>
<p>Finally, we will implement our custom recombination operator. Recombination operator inherits from <a class="el" href="classea_1_1_recombinator.html" title="The interface for recombination operator. ">Recombinator</a>, but similar to <a class="el" href="classea_1_1_typed_mutator.html" title="A Mutator which requires the input and output Genome of type T instead of Genome. ...">TypedMutator</a>, we knew that we want to use <a class="el" href="namespaceea.html#a60079f1a7f760e9ddf64370e88c73ca5">DoubleArrayGenome</a>, therefore our operator should derive from <a class="el" href="classea_1_1_typed_recombinator.html" title="A Recombinator which requires the input and output Genome of type T instead of Genome. ">TypedRecombinator</a>. Here is the implementation:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SphereCrossover: <span class="keyword">public</span> TypedRecombinator&lt;DoubleArrayGenome&gt; {</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> GetParentCount()<span class="keyword"> override </span>{</div><div class="line">        <span class="keywordflow">return</span> 2;</div><div class="line">    }</div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a> DoCombine(vector&lt;DoubleArrayGenomePtr&gt;&amp; pParents)<span class="keyword"> override </span>{</div><div class="line">        <a class="code" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a> newGenome = make_shared&lt;DoubleArrayGenome&gt;();</div><div class="line"></div><div class="line">        vector&lt;double&gt;&amp; x = pParents[0]-&gt;GetGenes();</div><div class="line">        vector&lt;double&gt;&amp; y = pParents[1]-&gt;GetGenes();</div><div class="line">        vector&lt;double&gt;&amp; z = newGenome-&gt;GetGenes();</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> alpha = <a class="code" href="classea_1_1_random.html#ac1494cf864d252f9bf25ac32cd65f2ff">Random::Rate</a>();</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> i = 0; i &lt; x.size(); i++)</div><div class="line">            z.push_back(alpha * x[i] + (1 - alpha) * y[i]);</div><div class="line"></div><div class="line">        Normalize(z);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> newGenome;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> The interface requires a vector of <a class="el" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a> as parents and produces a <a class="el" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a> as the child. The number of parents given to <a class="el" href="classea_1_1_recombinator.html#a9eeb446a6d3b025603711891decfaae4" title="Implementation of the recombination operator. ">Recombinator::DoCombine()</a> method is queried from the <a class="el" href="classea_1_1_recombinator.html#a29203bc41e684b96d7821944204b4b71" title="The number of parents required by this Recombinator. ">Recombinator::GetParentCount()</a> which returns 2 in this case.</p>
<p><div class="fragment"><div class="line">    <span class="keyword">virtual</span> <a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> GetParentCount()<span class="keyword"> override </span>{</div><div class="line">        <span class="keywordflow">return</span> 2;</div><div class="line">    }</div></div><!-- fragment --></p>
<p>Similar to <a class="el" href="classea_1_1_mutator.html" title="The interface for mutation operator. ">Mutator</a>, child <a class="el" href="classea_1_1_genome.html" title="The interface for representation. ">Genome</a> should be a <b>different object</b> and not share any pointer to its parents. We create a completely new DoubleArrayGenome using <a class="elRef" doxygen="/home/minh/repo/vgu_interns/EA/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared.html">std::make_shared()</a>:</p>
<p><div class="fragment"><div class="line">        <a class="code" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a> newGenome = make_shared&lt;DoubleArrayGenome&gt;();</div></div><!-- fragment --></p>
<p>Then we get the reference of parents' genes and also child's genes:</p>
<p><div class="fragment"><div class="line">        vector&lt;double&gt;&amp; x = pParents[0]-&gt;GetGenes();</div><div class="line">        vector&lt;double&gt;&amp; y = pParents[1]-&gt;GetGenes();</div><div class="line">        vector&lt;double&gt;&amp; z = newGenome-&gt;GetGenes();</div></div><!-- fragment --></p>
<p>The calculation is, again, very straight-forward. Remember, at the end, we must normalize the vector:</p>
<p><div class="fragment"><div class="line">        Normalize(z);</div></div><!-- fragment --></p>
<h2><a class="anchor" id="tut4-main"></a>
Main program</h2>
<p>In the last step, we merge everything into the main function. The structure of this main function is identical to the one described in <a class="el" href="tut1.html">Tutorial 1</a>. The only difference is the name of operators are changed to our custom operators: <code>SphereInitializer</code>, <code>SphereMutation</code> and <code>SphereCrossover</code>. Besides that, we also use <a class="el" href="classea_1_1_tournament_selection.html" title="Implementation of Tournament selection operator. ">TournamentSelection</a> as the survival selection mechanism and <a class="el" href="classea_1_1_generation_termination_hook.html" title="A Hook which terminates when the target generation number has been reached. ">GenerationTerminationHook</a> to terminate the algorithm based on the generation number.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define GENOME_LENGTH               25</span></div><div class="line"><span class="preprocessor">#define OFFSPRING_RATIO             1</span></div><div class="line"><span class="preprocessor">#define MUTATION_RATE               0.1</span></div><div class="line"><span class="preprocessor">#define POP_SIZE                    100</span></div><div class="line"><span class="preprocessor">#define TOURNAMENT_SIZE             5</span></div><div class="line"><span class="preprocessor">#define TARGET_GENERATION           10000</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="namespaceea.html#a5061ad2f4477daa266985d7cd0f7f1c6">EvolutionStrategyPtr</a> strategy = make_shared&lt;EvolutionStrategy&gt;(POP_SIZE);</div><div class="line"></div><div class="line">    strategy-&gt;initializer.Create&lt;SphereInitializer&gt;(GENOME_LENGTH);</div><div class="line"></div><div class="line">    strategy-&gt;mutators.CreateBase&lt;SphereMutation&gt;()-&gt;Rate(MUTATION_RATE);</div><div class="line"></div><div class="line">    strategy-&gt;recombinators.CreateBase&lt;SphereCrossover&gt;()-&gt;Parent&lt;UniformSelection&gt;()-&gt;Ratio(OFFSPRING_RATIO);</div><div class="line"></div><div class="line">    strategy-&gt;survivalSelector.Create&lt;TournamentSelection&gt;(TOURNAMENT_SIZE);</div><div class="line"></div><div class="line">    strategy-&gt;evaluator.Create&lt;TypedFunctionalEvaluator&lt;DoubleArrayGenome&gt;&gt;( [] (<span class="keyword">const</span> <a class="code" href="namespaceea.html#a28f6c7da694dbd57413b188e0fb3cb33">DoubleArrayGenomePtr</a>&amp; genome) {</div><div class="line">        vector&lt;double&gt;&amp; x = genome-&gt;GetGenes();</div><div class="line">        <a class="code" href="namespaceea.html#ae7e199d72692a6905f583e4623d91b92">uint</a> n = x.size();</div><div class="line">        <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/minh/repo/vgu_interns/EA/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/algorithm/accumulate.html">std::accumulate</a>(x.begin(), x.end(), <a class="codeRef" doxygen="/home/minh/repo/vgu_interns/EA/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/numeric/math/pow.html">pow</a>(n, n / 2.0), <a class="codeRef" doxygen="/home/minh/repo/vgu_interns/EA/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/functional/multiplies.html">std::multiplies&lt;double&gt;</a>());</div><div class="line">    });</div><div class="line"></div><div class="line">    strategy-&gt;hooks.Create&lt;StandardOutputHook&gt;();</div><div class="line">    strategy-&gt;hooks.Create&lt;GenerationTerminationHook&gt;(TARGET_GENERATION);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceea.html#af551c7bd55451130c5d94f3371c263b1">SessionPtr</a> session = strategy-&gt;Evolve();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="tut4-compile"></a>
Compile and Run</h1>
<p>Compile this program with <b>C++14 standard</b> as described in <a class="el" href="tut1.html">Tutorial 1</a>. </p><div class="fragment"><div class="line">g++ -std=c++14 -o SphereOpt SphereOpt.cpp -lopenea</div></div><!-- fragment --><p>Here is the output example when run the program (some lines of the evolution process are omitted). It may not be the same on your machine because the evolutionary process is stochastic. </p><div class="fragment"><div class="line">[2017-06-27 14:33:57.777922] Parallel processing is enabled, number of threads = 4</div><div class="line">[2017-06-27 14:33:57.787531] Population initialized, evaluation 100</div><div class="line">[2017-06-27 14:33:57.787597] Evolution started from generation 0, evaluation 100</div><div class="line">Gen       1 Best =   0.263902   0.2231-0.2153-0.2611-0.2893-0.2659-0.1449-0.1930-0.1854-0.1632- ...</div><div class="line">Gen       2 Best =   0.349648   0.1970-0.1747-0.2298-0.2863-0.2859-0.1826-0.2127-0.1957-0.1828- ...</div><div class="line">Gen       3 Best =   0.635857   0.2185-0.1901-0.2242-0.2226-0.2448-0.1861-0.2113-0.2028-0.1772- ...</div><div class="line">...</div><div class="line">Gen   9,998 Best =   0.999992   0.1999-0.2001-0.2001-0.2000-0.2000-0.2001-0.1999-0.2000-0.2001- ...</div><div class="line">Gen   9,999 Best =   0.999992   0.1999-0.2001-0.2001-0.2000-0.2000-0.2001-0.1999-0.2000-0.2001- ...</div><div class="line">Gen  10,000 Best =   0.999992   0.1999-0.2001-0.2001-0.2000-0.2000-0.2001-0.1999-0.2000-0.2001- ...</div><div class="line">[2017-06-27 14:34:08.009264] GenerationTerminationHook: Reached generation #10000 &gt;= 10000. Terminating...</div><div class="line">[2017-06-27 14:34:08.009290] Evolution stopped at generation 10000, evaluation 1000100</div><div class="line">[2017-06-27 14:34:08.009309] Time Report: [S] 0.289283 [M] 0.135669 [E] 0.24971 [F] 0.0906382 [Total] 0.84278 ms</div></div><!-- fragment --><p>While running the program, you may see a speed tracker like this:</p>
<div class="fragment"><div class="line">Gen    807 / 10,000     8.1%    Spd: 1757.211 g/s    ETA: 05s</div></div><!-- fragment --><p>This is automatically turned on when you use <a class="el" href="classea_1_1_generation_termination_hook.html" title="A Hook which terminates when the target generation number has been reached. ">GenerationTerminationHook</a> or <a class="el" href="classea_1_1_evaluation_termination_hook.html" title="A Hook which terminates when the target evaluation number has been reached. ">EvaluationTerminationHook</a>.</p>
<p>You can see the final fitness of the optimization process is near \(1\) and the genes in the final genome are near \(\frac{1}{\sqrt{n}} = \frac{1}{\sqrt{25}} = 0.2\) which match with the expected result.</p>
<h1><a class="anchor" id="tut4-conclution"></a>
Conclusion</h1>
<p>In this tutorial, you have known how to extend the framework by implementing custom operators for <a class="el" href="classea_1_1_initializer.html" title="The interface for initialization method. ">Initializer</a>, <a class="el" href="classea_1_1_mutator.html" title="The interface for mutation operator. ">Mutator</a> and <a class="el" href="classea_1_1_recombinator.html" title="The interface for recombination operator. ">Recombinator</a> interfaces. Besides that, you also learned about <a class="el" href="classea_1_1_typed_mutator.html" title="A Mutator which requires the input and output Genome of type T instead of Genome. ...">TypedMutator</a> and <a class="el" href="classea_1_1_typed_recombinator.html" title="A Recombinator which requires the input and output Genome of type T instead of Genome. ">TypedRecombinator</a> to handle type-casting automatically and worked with <a class="el" href="namespaceea.html#a60079f1a7f760e9ddf64370e88c73ca5">DoubleArrayGenome</a> and smart pointers intensively.</p>
<p>In the next tutorial, we will bundle our custom operators into a plugin and load it dynamically using the CLI:</p>
<p><a class="el" href="tut5.html">Bundle custom operators into a Plugin</a></p>
<dl class="section note"><dt>Note</dt><dd>It seems redundant to write a lot of code in order to do such simple calculations. But in a long run, it will save you a lot of time debugging and implementing auxiliary modules such as <a class="el" href="classea_1_1_backup_hook.html" title="A Hook which backs up the Population to file. ">BackupHook</a> or <a class="el" href="classea_1_1_multi_threading.html" title="Static class providing multi-threading feature. ">MultiThreading</a>. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
